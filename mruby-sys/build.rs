use std::env;
use std::path::{Path, PathBuf};
use std::process::Command;

/// mruby source root
const MRUBY: &str = "mruby-2.0.1";
/// mruby header dir
const MRUBY_INCLUDE_DIR: &str = "mruby-2.0.1/include";
/// target directory for libmruby.a generated by rake build inside the build
/// root
const MRUBY_OUT_DIR: &str = "host/lib";
/// env var to force a clean build
const MRUBY_SYS_CLEAN: &str = "MRUBY_SYS_CLEAN";

/// Crate root.
fn root() -> String {
    env::var("CARGO_MANIFEST_DIR").unwrap()
}

/// Set env variable `MRUBY_SYS_CLEAN` to force a clean build and bindgen.
fn is_clean_build() -> bool {
    env::var(MRUBY_SYS_CLEAN).is_ok()
}

/// Build libruby.a static library if a clean build or the lib doesn't exist.
fn should_build_lib(build_root: &Path) -> bool {
    let lib: PathBuf = [
        "{}/{}/libmruby.a",
        build_root.to_str().unwrap(),
        MRUBY_OUT_DIR,
    ]
    .iter()
    .collect();
    is_clean_build() || !lib.exists()
}

/// Run bindgen to generate FFI bindings if a clean build or we are building
/// libruby.a static library.
fn should_run_bindgen(build_root: &Path) -> bool {
    is_clean_build() || should_build_lib(build_root)
}

fn main() {
    let build_root: PathBuf = [&env::var("OUT_DIR").unwrap(), "mruby-build"]
        .iter()
        .collect();
    // Only build mruby if the static lib is not already built or if this is a
    // clean build. The source doesn't change so we can "cache" the lib.
    if should_build_lib(&build_root) {
        let mruby_dir: PathBuf = [&root(), MRUBY].iter().collect();

        // Build the mruby static library with its built in rake build system
        // rake dynamically generates some c source files so we can't build
        // directly with the `cc` crate.
        if !Command::new("rake")
            .env("MRUBY_BUILD_DIR", build_root.to_str().unwrap())
            .current_dir(mruby_dir.to_str().unwrap())
            .status()
            .unwrap()
            .success()
        {
            panic!("Failed to install react deps");
        }
    }

    // Set static lib and search path flags so rustc will link libmruby.a
    // into our binary.
    println!("cargo:rustc-link-lib=static=mruby");
    println!(
        "cargo:rustc-link-search=native={}/{}",
        &build_root.to_str().unwrap(),
        MRUBY_OUT_DIR,
    );

    // Build the extension library
    cc::Build::new()
        .file(format!("{}/ext/src/mruby-sys.c", root()))
        .include(MRUBY_INCLUDE_DIR)
        .include(format!("{}/ext/include", root()))
        .compile("libmrubysys.a");

    // Only run bindgen if this is a clean build. The source doesn't change so
    // we can "cache" the headers.
    if should_run_bindgen(&build_root) {
        let bindings_path: PathBuf = [&root(), "src", "ffi.rs"].iter().collect();
        let header_path: PathBuf = [&root(), "bindgen.h"].iter().collect();
        let bindings = bindgen::Builder::default()
            .header(header_path.to_str().expect("bindgen.h path"))
            .header(format!("{}/ext/include/mruby-sys.h", root()))
            .clang_arg(format!("-I{}", MRUBY_INCLUDE_DIR))
            .clang_arg(format!("-I{}/ext/include", root()))
            .generate()
            .expect("Unable to generate mruby bindings");
        bindings
            .write_to_file(bindings_path)
            .expect("Unable to write mruby bindings");
    }

    println!("cargo:rerun-if-env-changed={}", MRUBY_SYS_CLEAN);
}
